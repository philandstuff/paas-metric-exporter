// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"
	"time"

	"github.com/alphagov/paas-metric-exporter/metrics"
)

type FakeSender struct {
	Gauge2Stub        func(metric metrics.GaugeMetric) error
	gauge2Mutex       sync.RWMutex
	gauge2ArgsForCall []struct {
		metric metrics.GaugeMetric
	}
	gauge2Returns struct {
		result1 error
	}
	gauge2ReturnsOnCall map[int]struct {
		result1 error
	}
	GaugeStub        func(stat string, value int64) error
	gaugeMutex       sync.RWMutex
	gaugeArgsForCall []struct {
		stat  string
		value int64
	}
	gaugeReturns struct {
		result1 error
	}
	gaugeReturnsOnCall map[int]struct {
		result1 error
	}
	FGauge2Stub        func(metric metrics.FGaugeMetric) error
	fGauge2Mutex       sync.RWMutex
	fGauge2ArgsForCall []struct {
		metric metrics.FGaugeMetric
	}
	fGauge2Returns struct {
		result1 error
	}
	fGauge2ReturnsOnCall map[int]struct {
		result1 error
	}
	FGaugeStub        func(stat string, value float64) error
	fGaugeMutex       sync.RWMutex
	fGaugeArgsForCall []struct {
		stat  string
		value float64
	}
	fGaugeReturns struct {
		result1 error
	}
	fGaugeReturnsOnCall map[int]struct {
		result1 error
	}
	Incr2Stub        func(metric metrics.CounterMetric) error
	incr2Mutex       sync.RWMutex
	incr2ArgsForCall []struct {
		metric metrics.CounterMetric
	}
	incr2Returns struct {
		result1 error
	}
	incr2ReturnsOnCall map[int]struct {
		result1 error
	}
	IncrStub        func(stat string, count int64) error
	incrMutex       sync.RWMutex
	incrArgsForCall []struct {
		stat  string
		count int64
	}
	incrReturns struct {
		result1 error
	}
	incrReturnsOnCall map[int]struct {
		result1 error
	}
	Timing2Stub        func(metric metrics.TimingMetric) error
	timing2Mutex       sync.RWMutex
	timing2ArgsForCall []struct {
		metric metrics.TimingMetric
	}
	timing2Returns struct {
		result1 error
	}
	timing2ReturnsOnCall map[int]struct {
		result1 error
	}
	TimingStub        func(string, int64) error
	timingMutex       sync.RWMutex
	timingArgsForCall []struct {
		arg1 string
		arg2 int64
	}
	timingReturns struct {
		result1 error
	}
	timingReturnsOnCall map[int]struct {
		result1 error
	}
	PrecisionTiming2Stub        func(metric metrics.PrecisionTimingMetric) error
	precisionTiming2Mutex       sync.RWMutex
	precisionTiming2ArgsForCall []struct {
		metric metrics.PrecisionTimingMetric
	}
	precisionTiming2Returns struct {
		result1 error
	}
	precisionTiming2ReturnsOnCall map[int]struct {
		result1 error
	}
	PrecisionTimingStub        func(stat string, delta time.Duration) error
	precisionTimingMutex       sync.RWMutex
	precisionTimingArgsForCall []struct {
		stat  string
		delta time.Duration
	}
	precisionTimingReturns struct {
		result1 error
	}
	precisionTimingReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSender) Gauge2(metric metrics.GaugeMetric) error {
	fake.gauge2Mutex.Lock()
	ret, specificReturn := fake.gauge2ReturnsOnCall[len(fake.gauge2ArgsForCall)]
	fake.gauge2ArgsForCall = append(fake.gauge2ArgsForCall, struct {
		metric metrics.GaugeMetric
	}{metric})
	fake.recordInvocation("Gauge2", []interface{}{metric})
	fake.gauge2Mutex.Unlock()
	if fake.Gauge2Stub != nil {
		return fake.Gauge2Stub(metric)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.gauge2Returns.result1
}

func (fake *FakeSender) Gauge2CallCount() int {
	fake.gauge2Mutex.RLock()
	defer fake.gauge2Mutex.RUnlock()
	return len(fake.gauge2ArgsForCall)
}

func (fake *FakeSender) Gauge2ArgsForCall(i int) metrics.GaugeMetric {
	fake.gauge2Mutex.RLock()
	defer fake.gauge2Mutex.RUnlock()
	return fake.gauge2ArgsForCall[i].metric
}

func (fake *FakeSender) Gauge2Returns(result1 error) {
	fake.Gauge2Stub = nil
	fake.gauge2Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) Gauge2ReturnsOnCall(i int, result1 error) {
	fake.Gauge2Stub = nil
	if fake.gauge2ReturnsOnCall == nil {
		fake.gauge2ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.gauge2ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) Gauge(stat string, value int64) error {
	fake.gaugeMutex.Lock()
	ret, specificReturn := fake.gaugeReturnsOnCall[len(fake.gaugeArgsForCall)]
	fake.gaugeArgsForCall = append(fake.gaugeArgsForCall, struct {
		stat  string
		value int64
	}{stat, value})
	fake.recordInvocation("Gauge", []interface{}{stat, value})
	fake.gaugeMutex.Unlock()
	if fake.GaugeStub != nil {
		return fake.GaugeStub(stat, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.gaugeReturns.result1
}

func (fake *FakeSender) GaugeCallCount() int {
	fake.gaugeMutex.RLock()
	defer fake.gaugeMutex.RUnlock()
	return len(fake.gaugeArgsForCall)
}

func (fake *FakeSender) GaugeArgsForCall(i int) (string, int64) {
	fake.gaugeMutex.RLock()
	defer fake.gaugeMutex.RUnlock()
	return fake.gaugeArgsForCall[i].stat, fake.gaugeArgsForCall[i].value
}

func (fake *FakeSender) GaugeReturns(result1 error) {
	fake.GaugeStub = nil
	fake.gaugeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) GaugeReturnsOnCall(i int, result1 error) {
	fake.GaugeStub = nil
	if fake.gaugeReturnsOnCall == nil {
		fake.gaugeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.gaugeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) FGauge2(metric metrics.FGaugeMetric) error {
	fake.fGauge2Mutex.Lock()
	ret, specificReturn := fake.fGauge2ReturnsOnCall[len(fake.fGauge2ArgsForCall)]
	fake.fGauge2ArgsForCall = append(fake.fGauge2ArgsForCall, struct {
		metric metrics.FGaugeMetric
	}{metric})
	fake.recordInvocation("FGauge2", []interface{}{metric})
	fake.fGauge2Mutex.Unlock()
	if fake.FGauge2Stub != nil {
		return fake.FGauge2Stub(metric)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fGauge2Returns.result1
}

func (fake *FakeSender) FGauge2CallCount() int {
	fake.fGauge2Mutex.RLock()
	defer fake.fGauge2Mutex.RUnlock()
	return len(fake.fGauge2ArgsForCall)
}

func (fake *FakeSender) FGauge2ArgsForCall(i int) metrics.FGaugeMetric {
	fake.fGauge2Mutex.RLock()
	defer fake.fGauge2Mutex.RUnlock()
	return fake.fGauge2ArgsForCall[i].metric
}

func (fake *FakeSender) FGauge2Returns(result1 error) {
	fake.FGauge2Stub = nil
	fake.fGauge2Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) FGauge2ReturnsOnCall(i int, result1 error) {
	fake.FGauge2Stub = nil
	if fake.fGauge2ReturnsOnCall == nil {
		fake.fGauge2ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fGauge2ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) FGauge(stat string, value float64) error {
	fake.fGaugeMutex.Lock()
	ret, specificReturn := fake.fGaugeReturnsOnCall[len(fake.fGaugeArgsForCall)]
	fake.fGaugeArgsForCall = append(fake.fGaugeArgsForCall, struct {
		stat  string
		value float64
	}{stat, value})
	fake.recordInvocation("FGauge", []interface{}{stat, value})
	fake.fGaugeMutex.Unlock()
	if fake.FGaugeStub != nil {
		return fake.FGaugeStub(stat, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.fGaugeReturns.result1
}

func (fake *FakeSender) FGaugeCallCount() int {
	fake.fGaugeMutex.RLock()
	defer fake.fGaugeMutex.RUnlock()
	return len(fake.fGaugeArgsForCall)
}

func (fake *FakeSender) FGaugeArgsForCall(i int) (string, float64) {
	fake.fGaugeMutex.RLock()
	defer fake.fGaugeMutex.RUnlock()
	return fake.fGaugeArgsForCall[i].stat, fake.fGaugeArgsForCall[i].value
}

func (fake *FakeSender) FGaugeReturns(result1 error) {
	fake.FGaugeStub = nil
	fake.fGaugeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) FGaugeReturnsOnCall(i int, result1 error) {
	fake.FGaugeStub = nil
	if fake.fGaugeReturnsOnCall == nil {
		fake.fGaugeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fGaugeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) Incr2(metric metrics.CounterMetric) error {
	fake.incr2Mutex.Lock()
	ret, specificReturn := fake.incr2ReturnsOnCall[len(fake.incr2ArgsForCall)]
	fake.incr2ArgsForCall = append(fake.incr2ArgsForCall, struct {
		metric metrics.CounterMetric
	}{metric})
	fake.recordInvocation("Incr2", []interface{}{metric})
	fake.incr2Mutex.Unlock()
	if fake.Incr2Stub != nil {
		return fake.Incr2Stub(metric)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.incr2Returns.result1
}

func (fake *FakeSender) Incr2CallCount() int {
	fake.incr2Mutex.RLock()
	defer fake.incr2Mutex.RUnlock()
	return len(fake.incr2ArgsForCall)
}

func (fake *FakeSender) Incr2ArgsForCall(i int) metrics.CounterMetric {
	fake.incr2Mutex.RLock()
	defer fake.incr2Mutex.RUnlock()
	return fake.incr2ArgsForCall[i].metric
}

func (fake *FakeSender) Incr2Returns(result1 error) {
	fake.Incr2Stub = nil
	fake.incr2Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) Incr2ReturnsOnCall(i int, result1 error) {
	fake.Incr2Stub = nil
	if fake.incr2ReturnsOnCall == nil {
		fake.incr2ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.incr2ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) Incr(stat string, count int64) error {
	fake.incrMutex.Lock()
	ret, specificReturn := fake.incrReturnsOnCall[len(fake.incrArgsForCall)]
	fake.incrArgsForCall = append(fake.incrArgsForCall, struct {
		stat  string
		count int64
	}{stat, count})
	fake.recordInvocation("Incr", []interface{}{stat, count})
	fake.incrMutex.Unlock()
	if fake.IncrStub != nil {
		return fake.IncrStub(stat, count)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.incrReturns.result1
}

func (fake *FakeSender) IncrCallCount() int {
	fake.incrMutex.RLock()
	defer fake.incrMutex.RUnlock()
	return len(fake.incrArgsForCall)
}

func (fake *FakeSender) IncrArgsForCall(i int) (string, int64) {
	fake.incrMutex.RLock()
	defer fake.incrMutex.RUnlock()
	return fake.incrArgsForCall[i].stat, fake.incrArgsForCall[i].count
}

func (fake *FakeSender) IncrReturns(result1 error) {
	fake.IncrStub = nil
	fake.incrReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) IncrReturnsOnCall(i int, result1 error) {
	fake.IncrStub = nil
	if fake.incrReturnsOnCall == nil {
		fake.incrReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.incrReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) Timing2(metric metrics.TimingMetric) error {
	fake.timing2Mutex.Lock()
	ret, specificReturn := fake.timing2ReturnsOnCall[len(fake.timing2ArgsForCall)]
	fake.timing2ArgsForCall = append(fake.timing2ArgsForCall, struct {
		metric metrics.TimingMetric
	}{metric})
	fake.recordInvocation("Timing2", []interface{}{metric})
	fake.timing2Mutex.Unlock()
	if fake.Timing2Stub != nil {
		return fake.Timing2Stub(metric)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.timing2Returns.result1
}

func (fake *FakeSender) Timing2CallCount() int {
	fake.timing2Mutex.RLock()
	defer fake.timing2Mutex.RUnlock()
	return len(fake.timing2ArgsForCall)
}

func (fake *FakeSender) Timing2ArgsForCall(i int) metrics.TimingMetric {
	fake.timing2Mutex.RLock()
	defer fake.timing2Mutex.RUnlock()
	return fake.timing2ArgsForCall[i].metric
}

func (fake *FakeSender) Timing2Returns(result1 error) {
	fake.Timing2Stub = nil
	fake.timing2Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) Timing2ReturnsOnCall(i int, result1 error) {
	fake.Timing2Stub = nil
	if fake.timing2ReturnsOnCall == nil {
		fake.timing2ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.timing2ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) Timing(arg1 string, arg2 int64) error {
	fake.timingMutex.Lock()
	ret, specificReturn := fake.timingReturnsOnCall[len(fake.timingArgsForCall)]
	fake.timingArgsForCall = append(fake.timingArgsForCall, struct {
		arg1 string
		arg2 int64
	}{arg1, arg2})
	fake.recordInvocation("Timing", []interface{}{arg1, arg2})
	fake.timingMutex.Unlock()
	if fake.TimingStub != nil {
		return fake.TimingStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.timingReturns.result1
}

func (fake *FakeSender) TimingCallCount() int {
	fake.timingMutex.RLock()
	defer fake.timingMutex.RUnlock()
	return len(fake.timingArgsForCall)
}

func (fake *FakeSender) TimingArgsForCall(i int) (string, int64) {
	fake.timingMutex.RLock()
	defer fake.timingMutex.RUnlock()
	return fake.timingArgsForCall[i].arg1, fake.timingArgsForCall[i].arg2
}

func (fake *FakeSender) TimingReturns(result1 error) {
	fake.TimingStub = nil
	fake.timingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) TimingReturnsOnCall(i int, result1 error) {
	fake.TimingStub = nil
	if fake.timingReturnsOnCall == nil {
		fake.timingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.timingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) PrecisionTiming2(metric metrics.PrecisionTimingMetric) error {
	fake.precisionTiming2Mutex.Lock()
	ret, specificReturn := fake.precisionTiming2ReturnsOnCall[len(fake.precisionTiming2ArgsForCall)]
	fake.precisionTiming2ArgsForCall = append(fake.precisionTiming2ArgsForCall, struct {
		metric metrics.PrecisionTimingMetric
	}{metric})
	fake.recordInvocation("PrecisionTiming2", []interface{}{metric})
	fake.precisionTiming2Mutex.Unlock()
	if fake.PrecisionTiming2Stub != nil {
		return fake.PrecisionTiming2Stub(metric)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.precisionTiming2Returns.result1
}

func (fake *FakeSender) PrecisionTiming2CallCount() int {
	fake.precisionTiming2Mutex.RLock()
	defer fake.precisionTiming2Mutex.RUnlock()
	return len(fake.precisionTiming2ArgsForCall)
}

func (fake *FakeSender) PrecisionTiming2ArgsForCall(i int) metrics.PrecisionTimingMetric {
	fake.precisionTiming2Mutex.RLock()
	defer fake.precisionTiming2Mutex.RUnlock()
	return fake.precisionTiming2ArgsForCall[i].metric
}

func (fake *FakeSender) PrecisionTiming2Returns(result1 error) {
	fake.PrecisionTiming2Stub = nil
	fake.precisionTiming2Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) PrecisionTiming2ReturnsOnCall(i int, result1 error) {
	fake.PrecisionTiming2Stub = nil
	if fake.precisionTiming2ReturnsOnCall == nil {
		fake.precisionTiming2ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.precisionTiming2ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) PrecisionTiming(stat string, delta time.Duration) error {
	fake.precisionTimingMutex.Lock()
	ret, specificReturn := fake.precisionTimingReturnsOnCall[len(fake.precisionTimingArgsForCall)]
	fake.precisionTimingArgsForCall = append(fake.precisionTimingArgsForCall, struct {
		stat  string
		delta time.Duration
	}{stat, delta})
	fake.recordInvocation("PrecisionTiming", []interface{}{stat, delta})
	fake.precisionTimingMutex.Unlock()
	if fake.PrecisionTimingStub != nil {
		return fake.PrecisionTimingStub(stat, delta)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.precisionTimingReturns.result1
}

func (fake *FakeSender) PrecisionTimingCallCount() int {
	fake.precisionTimingMutex.RLock()
	defer fake.precisionTimingMutex.RUnlock()
	return len(fake.precisionTimingArgsForCall)
}

func (fake *FakeSender) PrecisionTimingArgsForCall(i int) (string, time.Duration) {
	fake.precisionTimingMutex.RLock()
	defer fake.precisionTimingMutex.RUnlock()
	return fake.precisionTimingArgsForCall[i].stat, fake.precisionTimingArgsForCall[i].delta
}

func (fake *FakeSender) PrecisionTimingReturns(result1 error) {
	fake.PrecisionTimingStub = nil
	fake.precisionTimingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) PrecisionTimingReturnsOnCall(i int, result1 error) {
	fake.PrecisionTimingStub = nil
	if fake.precisionTimingReturnsOnCall == nil {
		fake.precisionTimingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.precisionTimingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.gauge2Mutex.RLock()
	defer fake.gauge2Mutex.RUnlock()
	fake.gaugeMutex.RLock()
	defer fake.gaugeMutex.RUnlock()
	fake.fGauge2Mutex.RLock()
	defer fake.fGauge2Mutex.RUnlock()
	fake.fGaugeMutex.RLock()
	defer fake.fGaugeMutex.RUnlock()
	fake.incr2Mutex.RLock()
	defer fake.incr2Mutex.RUnlock()
	fake.incrMutex.RLock()
	defer fake.incrMutex.RUnlock()
	fake.timing2Mutex.RLock()
	defer fake.timing2Mutex.RUnlock()
	fake.timingMutex.RLock()
	defer fake.timingMutex.RUnlock()
	fake.precisionTiming2Mutex.RLock()
	defer fake.precisionTiming2Mutex.RUnlock()
	fake.precisionTimingMutex.RLock()
	defer fake.precisionTimingMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSender) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ metrics.Sender = new(FakeSender)
